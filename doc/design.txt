SIMPLE PARSER
=============

1. Overview

The simple parser can be separated into 2 big modules:
	- XML Parsing module
	- XML Document generation module
Each module is quite separated from the other. The only thing linking the two is the DOM tree 
structure.

Version: 1.1

2. Data structure

2.1. DOM tree

2.1.1. Requirements

The DOM tree structure will have to include the following types of node:
	- Element node
	- Attribute node
	- Text node
The nodes in a tree must be able to link to each other using a pointer mechanism. Parents must be
able to reference their children and children must be able to reference their parents.

2.1.2. Detailed design

2.1.2.1. Element node

Each kind of node in a tree can be implemented as a struct. The fields of an element node that the 
struct should include are:
	- Name
	- Parent pointer
	- Children pointers
		+ Attribute pointers
		+ Text node pointers
		+ Element node pointers
	- Single tag or not

2.1.2.2. Attribute node

The fields of an attribute node that the struct should include are:
	- Name
	- Value
	- Parent pointer

2.1.2.3. Text node

The fields of a text node that the struct should include are:
	- Content
	- Parent pointer

2.2. XML declaration

For now, let's just use a string to store the XML declaration.

2.3. Other intermediate data structures

2.3.1. FIFO stack

Stack is used for storing elements while parsing XML documents. The nature of XML markup language 
makes FIFO stack a perfect tool to parse a document's element tags.

3. Workflow

3.1. XML Parsing

The workflow of the XML parsing function can be described (and implemented) as a FSM, presented in 
doc/images/xml-parsing-fsm.jpeg.
Errors can happen in each of these states and may disrupt the parsing process of the parser.

3.2. XML document generation

When already having a DOM tree, the XML document can be generated using a tree traversing algorithm 
(like depth-first search). The only issue to pay attention to is the formatting (whitespaces, new 
lines, indentation...).

4. Utility functions

This section lists important utility functions that are used in the code. The functions are listed 
by what they do, not by names (this is just a design draft).
	- Scan for a series of whitespaces
	- Scan for a series of whitespaces, turn up error if no whitespace is found
	- Scan for a string, stop at whitespace or a delimiter
	- Trim whitespace from a string
These functions were developed in custom-clib.

5. Specific workflow design

5.1. XML Parsing

5.1.1. 'Void' state

This state is when the parser is not going through any element tag or text node. It is about to 
enter a mode of parsing one of those.

Pseudo code:
	eat_whitespaces()
	rv = handle_tag_starting()
	if (rv == 2)
		to_state(Element closing tag)
	else if (rv == 1)
		to_state(Element opening tag)
	else
		to_state(Text)

The funtion handle_tag_starting() might be used in many states and have the following pseudo code:
	c = fgetc()
	if (c == '<')
		c2 = fgetc()
		if (c2 == '/')
			return 2
		else
			rewind(1)
			return 1
	else
		rewind(1)
		return 0

5.1.2. 'Element opening tag' state

This state is when the parser is starting to go through an element opening tag.

Pseudo code:
	tag = fgets()
	verify(tag)
	push(elem_stack, tag)
	add(current, tag)
	current = tag
	eat_whitespaces()
	if (handle_tag_ending())
		to_state(Void)
	else
		to_state(Attribute)

The function handle_tag_ending() might be used in many states and have the following pseudo code:
	c = fgetc()
	if (c == '/')
		c1 = fgetc()
		if (c1 == '>')
			pop(elem_stack)
			return 1
		else
			error()
	else if (c == '>')
		return 1
	else
		rewind(1)
		return 0


5.1.3. 'Attribute' state

This state is when the parser is starting to go through an attribute.

Pseudo code:
	att_key = trim(fget_before_delim("="))
	verify(att_key)
	forward(1)
	att_value = remove("\"", fgets_ignore())
	verify(att_value)
	add(current, att_key, att_value)
	eat_whitespaces()
	if (handle_tag_ending())
		to_state(Void)
	else
		to_state(Attribute)

5.1.4. 'Text' state

This state is when the parser is starting to go through a text node.

Pseudo code:
	text = trim(fget_before_delim("<"))
	verify(text)
	add(current, text)
	rv = handle_tag_starting()
	if (rv == 2)
		to_state(Element closing tag)
	else if (rv == 1)
		to_state(Element opening tag)
	else
		error()

5.1.5. 'Element closing tag' state

This state is when the parser is starting to go through an element closing tag.

Pseudo code:
	tag = fget_before_delim(">")
	verify(tag)
	if (tag != pop(elem_stack))
		error()
	fgetc()
	up(current)
	eat_whitespaces()
	rv = handle_tag_starting()
	if (rv == 2)
		error()
	else if (rv == 1)
		to_start(Element opening tag)
	else
		to_state(Text)

5.2. XML document generation

Given a DOM tree, generating the XML document could be done using a recursive algorithm like 
depth-first search. The pseudo code is as follow:

write_dps(doc, node)
	if (node.type == text)
		writeln(doc, node.content)
	else
		write_opening_tag(doc, node)
		foreach (att in node.attributes)
			write_att(doc, att)
		if (node.single_tag)
			writeln(doc, '/>')
		else
			writeln(doc, '>')
			indent()
			foreach(child in node.nodes)
				write_dps(doc, child)
			unindent()
			write_closing_tag(doc, node)

generate(doc, tree, declaration)
	writeln(doc, declaration)
	write_dps(doc, tree.root)

6. Modulization

The parser will be implemented as 3 main modules (or files):
	- parse.c: take care of XML parsing
	- gen.c: take care of XML document generation
	- validate.c: take care of validating XML elements
	- main.c: main program, provides an interface to test and a simple use of the parser

7. Error handling

This section will be taken care of later.